<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="resources/style.css">
  <title>A Bit Wise blog</title>
</head>
<body>
  <header>
    <h1><a href="./index.html">A Bit Wise</a></h1>
    <h2>A blog about the basics</h2>
  </header>
  <div class="border-total"><div class=border-substance></div></div>
<aside>
  <nav>
    <h3>tags</h3>
    <p><a href="./tag-operators.html">operators</a></p>
    <p><a href="./tag-JavaScript.html">JavaScript</a></p>
    <p><a href="./tag-evaluation-strategy.html">evaluation strategy</a></p>
    <p><a href="./tag-call-by-sharing.html">call by sharing</a></p>
    <p><a href="./tag-call-by-value.html">call by value</a></p>
    <p><a href="./tag-call-by-reference.html">call by reference</a></p>
    <p><a href="./tag-data-types.html">data types</a></p>
    <p><a href="./tag-fundamentals.html">fundamentals</a></p>
    <p><a href="./tag-logic.html">logic</a></p>
    <p><a href="./tag-conditionals.html">conditionals</a></p>
    <p><a href="./tag-PowerShell.html">PowerShell</a></p>
    <p><a href="./tag-tips.html">tips</a></p>
    <p><a href="./tag-boot-order.html">boot order</a></p>
    <p><a href="./tag-dual-boot.html">dual-boot</a></p>
    <p><a href="./tag-windows.html">windows</a></p>
    <p><a href="./tag-regular-expressions.html">regular expressions</a></p>
  </nav>
</aside>
  <main>
    <article class="post">
      <span class="post-title-bar"><h2 id="= the assignment operator" class="post-title">= the assignment operator</h2><p class="meta-info">24/03/2019<br><a href="./tag-operators.html">operators</a>, <a href="./tag-JavaScript.html">JavaScript</a>, <a href="./tag-evaluation-strategy.html">evaluation strategy</a>, <a href="./tag-call-by-sharing.html">call by sharing</a>, <a href="./tag-call-by-value.html">call by value</a>, <a href="./tag-call-by-reference.html">call by reference</a>, <a href="./tag-data-types.html">data types</a></p></span>
      <div class="post-content">
        <p>When I started to program I didn’t really think about the question of what the references of my variables ‘were’ - they were just what I saw when I called functions like console.log(). Well, it’s not quite so simple, and understanding how variables refer will pay dividends.</p>
        <h3>1. A question</h3>
        <p>When you define two variables with the same value, like</p>
        <pre><code>
let one = 1
let uno = 1
</code></pre>
        <p>are you creating</p>
        <pre><code>
a: two values
b: two variables that point to the same value?
</code></pre>
        <h3>2. An answer</h3>
        <p>I had originally assumed the former – two variables with the same value point to different objects - but in fact the answer is closer to the latter. I thought that the assignment operator was a kind of copy operator, which took the value on the right, created a new instance of it, and assigned it to the binding on the left. I didn't know the words at the time, but I thought that JavaScript was a <em>pass-by-value</em> language.</p>
        <p>I think that there are two reasons I thought this. The first is that assignment is right-associative. Syntactically, the right-hand side comes first, and is assigned to the left-hand-side. This is why code like this works:</p>
        <pre><code>
let one = 1;
let two = 2;
one = two;
one; // 2
</code></pre>
        <p>Despite this syntactic relationship, there is a deeper logical relationship. Logically, the left-hand side comes first, and is assigned to the right-hand side. The right-hand side is ‘real’ and the left-hand side is just a pointer. To see an example, we’ll have to address the second source of my confusion, a failure to appreciate the difference between primitive and reference data-types in JavaScript.</p>
        <p>In JavaScript every value is of either a primitive or a reference type. Primitive values are basic and ‘immutable’ - they cannot be changed. They include:</p>
        <ul>
  <li>Number</li>
  <li>String</li>
  <li>Boolean</li>
  <li>null and undefined</li>
</ul>
        <p>Reference types, on the other hand, can include primitives, and they are mutable. They include:</p>
        <ul>
  <li>Object</li>
  <li>Array</li>
  <li>Function</li>
</ul>
        <p>What assignment does is take the characters on its left-hand-side and turn them into a portal, as it were, to whatever value is on the right-hand-side. If you update the value on the right, as in:</p>
        <pre><code>
let a = 1;
a++;
</code></pre>
        <p>You are actually assigning a new, primitive value to a – in this case, the value is 2. It’s just the same for reference types:</p>
        <pre><code>
let b = [1];
b = [2];
</code></pre>
        <p>In this case, we are assigning a completely new array to b. The difference between reference types and primitives becomes relevant when you use reference types to create an insulating layer between the variable and some value.</p>
        <pre><code>
let a = [1];
let b = a;
a[0] += 999;
b; // [1000]
</code></pre>
        <p>On the third line, the assignment operator is still moving the pointer to a different reference. However, now, the pointer is index 0 of the array which is itself pointed to by the bindings a and b. Because this array is never replaced, changes inside the array are reflected in both variables.</p>
        <h3>3. Assignment without the assignment operator: function parameters</h3>
        <p>Finally, we should note that functions parameters and arguments work like variables declared with let or var and the assignment operator.</p>
        <p>So first off, what is a function parameter or argument? An argument is the value you give to the function when you call it, and a parameter is the name that the function uses, internally, to represent the argument.</p>
        <pre><code>
function myFunction(myParam) {
  return myParam;
}
let myArgument = 5;
myFunction(myArgument)
</code></pre>
        <p>Parameters and arguments are often conflated, but they are not the same thing. The relationship between parameter and argument is the same as the relationship between a let variable and its reference.</p>
        <p>If parameter is to argument as variable is to reference, the rules we discussed above apply here too:</p>
        <pre><code>
let a = [1];
function sideEffector(param) {
  param[0] *= 1000;
return “something irrelevant”; 
}
</code></pre>
        <pre><code>
sideEffector(a);
// “something irrelevant”
a;
//[1000]
</code></pre>
        <p>So beware!</p>
        <h3>4. A caveat</h3>
        <p>If we’re being nerdy about this – and to be fair, we are all nerds here – what I’ve said above is not completely true.</p>
        <p>In practice, we can behave as if assignment always adds a pointer to a value in memory. However, it handles this memory differently for primitives and for reference types. For reference types, it simply points the variable name to the value, and multiple variables can point to the same memory location. They can also do so independently of each other, so that, if one gets given a new address, the other won’t inherit it:</p>
        <pre><code>
let a = [1]
let b = a
a = [2]
b // [1]
</code></pre>
        <p>For primitives, assignment copies the primitive in question to a new memory location. This is because JavaScript is what’s known as a ‘pass by sharing’ language. That means that when you pass a value to a function or to the assignment operator, a duplicate of the value is created, but in the case of reference types, the value passed is the memory address. If you assign 10 to two different variables, there really will be two immutable 10 values in memory.</p>
        <p>This caveat has no practical impact on the model developed above. For instance, it has no impact on the equality operators == and === because they use different rules for primitives and for reference types. For reference types, == and === check the location in memory:</p>
        <pre><code>
let a = []
let b = a
let c = []
a === b // true
a ===c // false
</code></pre>
        <p>For primitives, == and === check equivalence</p>
        <pre><code>
let x = 10
let y = 10 // these two tens are in different places in memory, but because primitives typically take up very little memory, it doesn't matter
x === y // true
</code></pre>
        <p>Further reading:</p>
        <ul>
  <li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">call by sharing on Wikipedia</a> (if you dare)</li>
  <li><a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-assignment-operators">The ECMA spec on the assignment operator</a> (If you're a really big boi)</li>
  <li>This <b><a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/#call-by-sharing">blog post</a></b> is better than most - there's a lot of misinformation out there on this topic.</li>
</ul>

        <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer of collapsed text">
      </div>
      <h3 class="expandContractButton">Read more +</h3>
    </article>
    <article class="post">
      <span class="post-title-bar"><h2 id="|| and &&" class="post-title">|| and &&</h2><p class="meta-info">20/03/2020<br><a href="./tag-operators.html">operators</a>, <a href="./tag-fundamentals.html">fundamentals</a>, <a href="./tag-JavaScript.html">JavaScript</a>, <a href="./tag-logic.html">logic</a>, <a href="./tag-conditionals.html">conditionals</a></p></span>
      <div class="post-content">
        <p>Logic in programming does not map directly onto logic itself. This is fair enough. Logicians aren’t even sure, themselves, what logic is, while computers have to actually work. This means that logic in programming is something that one must learn about. When I first started programming, I lacked a clear and explicit guide and I found myself confused.</p>
        <p>One thing that surprised me was that the logical connectors || and && could both return values other than true and false. Another thing that surprised me was the way that logic used what’s called short-circuit evaluation. A third thing that surprised me was that you could combine these two facts to make || and && statements into conditional, i.e. if-then, statements. But before we get into any of that, we should give a short description of || and &&.</p>
        <h3>1. || and && 101</h3>
        <p>|| is an ‘or’ operator and && is an ‘and’ operator. They each have an arity of two – they take two operands, one on each side, and return a value which represents the logical relationship between their two operands.</p>
        <p>We typically represent these logical relationships with truth tables. Logic is taken to be bivalent: it only has two values, true or false – there is no third value, like ‘half true’ or ‘true in the right context’:</p>
        <div class="parallel-code">
<table>
  <tr>
    <th>true</th>
    <th>||</th>
    <th>true</th>
    <th>is...</th>
    <th>true</th>
  </tr>
          <tr>
    <th>true</th>
    <th>||</th>
    <th>false</th>
    <th>is...</th>
    <th>true</th>
  </tr>
          <tr>
    <th>false</th>
    <th>||</th>
    <th>false</th>
    <th>is...</th>
    <th>false</th>
  </tr>
          <tr>
    <th>false</th>
    <th>||</th>
    <th>true</th>
    <th>is...</th>
    <th>true</th>
  </tr>
        </table>
        <table>
          <tr>
    <th>true</th>
    <th>&&</th>
    <th>true</th>
    <th>is...</th>
    <th>true</th>
  </tr>
          <tr>
    <th>true</th>
    <th>&&</th>
    <th>false</th>
    <th>is...</th>
    <th>false</th>
  </tr>
          <tr>
    <th>false</th>
    <th>&&</th>
    <th>false</th>
    <th>is...</th>
    <th>false</th>
  </tr>
          <tr>
    <th>false</th>
    <th>&&</th>
    <th>true</th>
    <th>is...</th>
    <th>false</th>
  </tr>
        </table>
</div>
        <p>Let’s imagine that we have three variables, isInLondon, isLearningToProgram and isAMasterPrgrommaer.</p>
        <code><pre>
let isInLondon = true;
let isLearningToProgram = true;
let isAMasterProgrammer = false;
</pre></code>
        <p>We can feed these variables to || and && for idiomatic assessments of logical relationships:</p>
        <code><pre>
isInLondon && isLearningToProgram // true
isLearningToProgram || isAMasterProgrammer // true
isLearningToProgram && isAMasterProgrammer // false
</pre></code>
        <p>Note that || is ‘nonexclusive’:</p>
        <code><pre>
isInLondon || isLearningToProgram // true
</pre></code>
        <p>For this reason, || and && are inverse operators – each of them returns one value in three cases, and the other in one case. We could also implement an exclusive or (XOR), if we wanted to, in which the above logical statement would come out false. However, the XOR is less important in programming and in logic in general. We'll skip over it for now.</p>
        <h3>2. true v.s. truthy, false v.s. falsy</h3>
        <p>When we’re programming, we give more values than true and false to the logical operators. How does this work?</p>
        <p>It’s not quite like when you use logic in conversation. In conversation, like when you say ‘he is at home and eating dinner’, you feed the logical assertion two statements, sub in each statement for its truth-value at time of evaluation, and you see whether the whole expression is true. If it is, then the logical statement – an assertion of a logical relationship – is true and so should return a truth value.</p>
        <p>In JavaScript it's a bit different. Look at this code:</p>
        <code><pre>
"He's a master programmer" || "He's a whale" // "He's a master programmer"
"He's a whale" || "He's a master programmer" // "He's a whale"
"" || "He's a whale" // "He's a whale"
"He's a whale" || "" // "He's a whale"
</pre></code>
        <p>Alas the computer, on balance, seems sure that I am a whale. But how does it <em>get</em> to that conclusion? It is not, I am afraid to say, to do with the important question of whether I am a master programmer or a whale.</p>
        <p>This is because the computational notion of truth is somewhat divorced from the everyday one. For a computer, the question 'is it true?' is more like 'yes or no?' than 'is it an accurate representation of reality?' Computers were designed from the hardware up, and, at a basic level, they are collections of transistors which are either firing or not firing. Boolean logic, which was already a developed academic field, let the creators of modern computing use these two states - electricity or a lack of electricity - to represent information. True is represented, on a fundamental level, by a firing transistor, and false by a non-firing transistor. 1 and 0 can be used to the same effect as true and false - the symbol used does not matter, as long as the symbols are <em>binary</em> - that is, they let us represent two states.</p>
        <p>JavaScript has moved on from using single transistors to represent truth values. In JavaScript, there are various kinds of value, and they can <em>all</em> be used in logical operations, even though they are not true or false <em>per se</em>. But what we can learn from the foundations of computing is that computational notions of true and false are not really about truth or falsity - the degree to which a representation is accurate - at all. The creators of programming languages have to make more or less arbitrary decisions about what values should behave like they're true, and what values should behave like they're false. The values which behave like they're true, whether or not they are the value true themselves, are called <em>truthy</em> values. The values that behave like they're false, whether or not they are the value false themselves, are called <em>falsy</em> values.</p>
  
<p>A truthy or falsy value can, at any time, do the job of true and false when used in logic, either as the input to or output from a logical operation because they are temporarily coerced by the operator into Booleans.</p>
        <p>So how can we tell what values are truthy, and what falsy? It's pretty easy. Almost every value is truthy, and there are only seven falsy values:</p>
        <ul>
 <li>false</li>
 <li>0 and 0n</li>
 <li>empty strings</li>
 <li>undefined, null and NaN</li>
</ul>
        <p>(Note, though, that there is some <a href="https://github.com/denysdovhan/wtfjs#-is-truthy-but-not-true">funny business</a> about empty arrays and null.)</p>
        
<p>Now we can see how the computer realised that I'm a whale dressed as a human, and that I'm not a master programmer: In the first line of code above, || receives two truthy strings, and outputs a truthy string; in the third line of code above, || receives a truthy and falsy string, and outputs a truthy string. It's okay to output strings, rather than true or false, because the output of the system is just as truthy/falsy as the input. Consulting our truth tables from earlier, we can see that the operations have logically valid output.</p>
        <h3>3. Short-circuit evaluation</h3>
        <p>So, || and && don’t return truth values, but rather their left-hand-side (LHS) or right-hand-side (RHS) - two terms that will be cropping up a lot from here on. How do || and && decide which side to return, when they could return either of two?</p> 
        <p>Assessing the truth of a logical statement amounts to nothing more than checking the truth-value of the LHS and RHS. Programming languages, by convention, check first the left-hand-side and then the right-hand-side. Sometimes, after the first result, the conclusion is determined. For instance, in the statement:</p>
        <code><pre>
LHS && RHS
</pre></code>
        <p>if LHS is falsy, then, no matter what RHS is, the and-statement, as a whole, must be false. The computer can save time by just ceasing it’s evaluation after it finds LHS to be false. If it finds LHS to be true, it needs to proceed to RHS; if RHS is true, the and-statement is true, and if it is false then, even though LHS is true, the and-statement is false. Either way, though, if LHS is true the truth of the and-statement rests entirely on the value of RHS.</p>
        <p>The converse holds for || statements:</p>
        <code><pre>
LHS && RHS
</pre></code>
        <p>If LHS is true, then, by fiat, the or-statement is true. However, if LHS is false, we still need to check RHS. If it is true, the statement passes, but if it is false, the statement fails.</p>
        <p>Since || and && statements do not return truth values, but either the LHS or RHS, in</p>
        <code><pre>
LHS && RHS
</pre></code>
        <p>if LHS is false, we can return that; else, if LHS is true, we will return RHS. We don't even need to check whether RHS is truty or falsy; whatever it is, it will be logically valid. In</p>
        <code><pre>
LHS || RHS
</pre></code>
        <p>if LHS is true, we can return that; else, if LHS is false, we will return RHS.</p>
        <p>This is short-circuit evaluation. It is a simple, elegant and – dare I say it –  a logical solution. There is no need to compute  a third value (true or false) which represents the operator’s decision. It is guaranteed that we can repurpose one of the inputs, and that we will repurpose the leftmost appropriate input.</p>
        <p>Now, before we close off this section, we should think a little about the consequences of returning truthy and falsy values instead of true and false. Because we can rely on the explicit rules of short-circuit evaluation, we can use logic to do things like decide on our variable assignments for us:</p>
        <code><pre>
let a = 1
let b = “”
let c = a && b
c // “”
</pre></code>
        <h3>4. || and && and conditional logic</h3>
        <p>So far, we’ve covered the meaning of short-circuit evaluation and truthiness and falsiness for || and &&. But these are not the only logical operations we do when programming. One other thing we do is express conditional logic, logic which expresses if-then relationships. Such conditional logic, sometimes called flow-control, lets us establish branching possibilities within our programs.</p>
        <p>The most common kind of conditional statements are if statements, if-else statements, and if-else if -else statements (two if-else statements stuck together). First let’s look at an if statement:</p>
        <code><pre>
let a = 5;
if (a) {
  console.log(‘a is true’);
}
</pre></code>
        <p>Notice that in this statement, we do not need to say if (a == true). a’s truthiness is enough for the logic to execute.</p>
        <p>Sometimes we do want to use operators on values to generate new boolean values, as in this if-else if-else statement, where the < operator is used:</p>
        <code><pre>
if (a < 10) {
  console.log(‘less than ten’);
} else if (a < 50) {
  console.log(‘less than fifty’);
} else {
  console.log(‘wow a must be really big”);
}
</pre></code>
        <p>The output of this code is ‘less than ten’, even though, of course, a is less than fifty. What we see here is a chain of logic that has the same effect as short-circuit evaluation. The second condition, if (a < 50), is itself dependent on the falsity of the first condition, because it is attached to the first condition’s else statement. The second condition is effectively</p>
        <code><pre>
if (!(a < 10)) && (a < 50)
</pre></code>
        <p>Because of this, after the program satisfies that first condition, (a < 10), it simply stops looking at the other conditions, which are premised on the falsity of earlier conditions. To print both conditions, we could attach them to separate if statements, rather than premising later if statements on the else statements of earlier if statements.</p>
        <p>So we can see that conditional logic effectively short-circuits, and we saw earlier that || and && statements short-circuit too. This similarity cuts deep: it lets us use || and && to make conditional statements, and conditional statements to make || and && statements.</p>
        <p>Here are || and && implemented as functions that use conditional logic:</p>
        <code><pre>
  function or(leftHandSide, rightHandSide) {
    if (leftHandSide) {
      return leftHandSide;
    } else {
      return rightHandSide; 
    }
  }
</pre></code>
        <code><pre>
  function and(leftHandSide, rightHandSide) {
    if (leftHandSide) {
      return rightHandSide;
      } else {
      return leftHandSide;
      }
  }      
</pre></code>      
        <p>There’s a nice kind of symmetry here: the only difference between the two functions is what the truthiness of the LHS indicates. In the or function, it indicates that evaluation can stop. In the and function it indicates that evaluation must continue.</p>
        <p>We can implement a converse kind of functionality with || and && operators.</p>
        <code><pre>
  function ifThen(antecedent, consequent) {
    return antecedent && consequent;
  }
</pre></code>
        <code><pre>
  function ifNotThen(antecedent, consequent) {
    return antecedent || consequent;
  }  
</pre></code>      
        <p>I’ve introduced two new terms here, ‘antecedent’ and ‘consequent’. These just mean ‘the bit that comes before’ and ‘the bit that comes after’ in a conditional statement. In the statement ‘if I go to Alaska, I will fulfill a lifelong ambition’, ‘I go to Alaska’ is the antecedent, and ‘I will fulfill a lifelong ambition’ is the consequent.</p>
        <p>The two functions above are not that practical. But using the logical operators && and || to express conditions can be practical. Let’s take a realistic example, trying to parse a string and return an array that contains any numbers inside the string. Given the string:</p>
        <code><pre>
	‘1 2 ,4 &:\ 301’
</pre></code>
        <p>we should return</p>
  
<code><pre>
	[‘1’, ‘2’, ‘4’, ‘301’]
</pre></code>
        <p>To achieve this, we will use the match() function and feed match() a regex.  Our regex will look like this:</p>
        <code><pre>
	/[0-9]+/g
</pre></code>
        <p>[0-9] represents any character 0..9. The plus symbol means ‘one or more of what I preceded’ - [0-9]. The g is a flag which means global, and tells match() to return more than one match.</p>
        <p>We’re all set up, and writing this function should be simple enough.</p>
        <p>However, there is a hitch. A requirement of our function is that it returns an array, even if the array is empty. But match() has an idiosyncrasy: if it finds no matches, it doesn’t return an empty array or an empty string, but returns null.</p>
        <p>How are we to solve the problem? Recall that null is falsy. We can use this to our advantage with some conditional logic.</p>
        <code><pre>
  function findNumbers(string) {
  let result = string.match(/[0-9]+/g);
  if (result) {
   return result;
  } else {
    return [];
}
</pre></code>
        <p>This is all right, but it’s quite long. We can shorten the same logic with the ternary operator, a quick way to write if-else statements:</p>
        <code><pre>
  function findNumbers(string) {
  let result = string.match(/[0-9]+/g);
  return result ? result : [];
  // if result is truthy, return result, else, return []
}
</pre></code>
        <p>This is good. However, we can do even better with the || operator:</p>
        <code><pre>
  function findNumbers(string) {
  return string.match(/[0-9]+/g) || [];
}
</pre></code>
        <p>And this is where using || for conditional logic really shines.</p>
        <p>Of course, you should not always use || and &&. If you want to use multiple consequents, you should opt for the full-fledged if(){} else{} structure. And even for more compact if-else conditions, rather than if-then or if-not-then, the ternary operator is generally preferable.</p>
        <p>However, if what you want to say is ‘if a then b, else a’, or ‘if not a then b, else a’ - in other words, if you want to choose between two operands - consider using a && b or a || b. And remember, logic in programming doesn't really bear much of a relation to logic, or to truth and falsity - it's just an arbitrary set of rules for the transformation of data. </p>
        <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer of collapsed text">
      </div>
      <h3 class="expandContractButton">Read more +</h3>
    </article>
    <article class="post">
      <span class="post-title-bar"><h2 id="How to talk about operators" class="post-title">How to talk about operators</h2><p class="meta-info">17/02/2020<br><a href="./tag-operators.html">operators</a>, <a href="./tag-fundamentals.html">fundamentals</a>, <a href="./tag-JavaScript.html">JavaScript</a></p></span>
      <div class="post-content">
        <p>It doesn't need to be an awkward discussion. All we need is some simple <strong>vocabulary</strong></p>
        <h3>1. Arity</h3>
        <p>An operator’s arity is the number of arguments – also called operands – that it takes. For instance, comparison operators have an arity of two – they take two operands:</p>
        <pre><code>
	// true
	5 < 10
</code></pre>
        <p>Here, 5 is one operand and 10 is another.</p>
        <p>An arity of two is the most common arity in JavaScript. Some operators have an arity of 1:</p>
        <pre><code>
	!false
	// true
	typeof true
	// boolean
</code></pre>
        <p>One operator has an arity of three, the ternary operator. Ternary means 'composed of three parts' and the ternary operator is used to express conditional logic:</p>
        <pre><code>
	condition ? true : false
</code></pre>
        <p>The first operand, the bit to the left of the ?, is a condition to be evaluated. If it is evaluated to true, then the second operand, the bit in between ? and :, is executed. If the first operand is evaluated to false,  the third operand, the bit after :, is executed.</p>
        <pre><code>
	let iAmIvo = true;
	function amIIvo(bool) {
	  return bool ? ‘yup’ : ‘no’;
	}
	amIIvo(iAmIvo); // ‘yup’
</code></pre>
        <h3>2. Associativity</h3>
        <p>Next up is an operator’s associativity. This isn’t about how operators interact with each other (that’s precedence) but about how operands interact with each other and with the operator. Basically it is the direction in which operands are evaluated. It can be either right-to-left or left-to-right. When an operator is left-to-right associative, we sometimes say that it is left-associative, and when it is right-to-left associative, we sometimes say that it is right associative.</p>
        <p>Mathematical and logical operators are left-to-right associative:</p>
        <pre><code>
	10 – 5 // 5
	true || false // true
</code></pre>
        <p>The ternary operator is left-associative too:</p>
        <pre><code>
	condition ? ‘true’ : ‘false’
</code></pre>
        <p>Assignment, on the other hand, is right-to-left associative:</p>
        <pre><code>
	let a = 1;
	let b = 2;
	let c = a;
	c; // 1 
</code></pre>
        <p>Unary operators - operators with an arity of 1 - tend to be right-associative:</p>
        <pre><code>
	!false
	// true	
	typeof Object
	// “function”
</code></pre>
        <h3>3. Precedence</h3>
        <p>A function’s precedence expresses where it stands in relation to other operators. If it has a high precedence, it is evaluated early. This means that it has first dibs on its operands. If it has low precedence, it is evaluated later. It receives only the operands that other operators didn’t want, or have already processed.</p>
        <p>Look at this mathematical expression:</p>
        <pre><code>
	1 * (0 – 1) === 1 * 0 – 1
	// true
</code></pre>
        <p>Since it returns true, we can tell that the logical comparison operator === has lower precedence than the numerical operators. If it had high precedence – first dibs – it would compare (0 – 1) with (1), and find them nonequal. However, in actuality it compares -1 with -1 and finds them equal.</p>
        <h3>4. Putting it all together</h3>
        <p>Putting it all together, we can now explain exactly why compound expressions work like they do. Let's take an example:</p>
        <pre><code>
	2 * (4 – 1) !== 2 * 4 – 1 ? "they’re not equal" : "they’re equal"
</code></pre>
        <p>The operator with the highest precedence here is the grouping operator (), followed by *, so we should start with the sums,</p>
        <pre><code>
	2 * (4 – 1)
	2 * 4 – 1
</code></pre>
        <p>which resolve to 6 and 7 respectively. The brackets introduce a difference, not because the multiplication operator is further to the left than the subtraction operator, but because multiplication has a higher precedence than subtraction (following <a href="https://www.mathsisfun.com/operation-order-pemdas.html">PEMDAS/BIDMAS</a>).</p>
        <p>the operator with the next highest precedence is the inequality operator. It has an arity of two, and for this example it doesn't really matter whether it is right-associative or left-associative (in general, it is left-associative, so console.log('hello') !=== console.log('world') prints hello and then world and then returns false). In this example !== receives two numbers - 6 and 7 - and finds them to be unequal. Therefore it returns true.</p>
        <p>Finally we have the ternary operator, the lowest-precedence operator in the equation above. It is left-associative, so it looks first to its left-hand-side, and uses that information to decide between its remaining operands. Since its left-hand-side is the value true, it chooses its second operand, "they are not equal".</p>
        <p>These three properties, arity, associativity and precedence, neatly divide the conceptual space for operators. With them, you can say all that you need to say, and learn precisely about the relationships between operators. As a next step, you might want to consult a comparative table like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">this one</a>.</p>
        <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer of collapsed text">
      </div>
      <h3 class="expandContractButton">Read more +</h3>
    </article>
    <article class="post">
      <span class="post-title-bar"><h2 id="Quickly boot into BIOS/UEFI from PowerShell" class="post-title">Quickly boot into BIOS/UEFI from PowerShell</h2><p class="meta-info">13/02/2020<br><a href="./tag-PowerShell.html">PowerShell</a>, <a href="./tag-tips.html">tips</a>, <a href="./tag-boot-order.html">boot order</a>, <a href="./tag-dual-boot.html">dual-boot</a>, <a href="./tag-windows.html">windows</a></p></span>
      <div class="post-content">
        <p>I came up with this solution when trying to dual-boot Ubuntu and Windows 10 but having troulbe adjusting boot order. I wrote a Powershell function which, when executed, restarts the computer directly into the firmware settings. No more button-bashing, and a lot of time saved.</p>
        <p>To follow along you don't need any real PowerShell knowledge. Our strategy will be to define a function in your user PowerShell profile ($PROFILE), a text file which is read every time you open PowerShell. That way, the function will always be defined, and all you need to do is call it.</p> 
        <h3>1. Prepare your $PROFILE</h3>
        <p>This text file does not exist by default, but you might already have it. To see whether you do, enter</p>
        <code>test-path $PROFILE</code>
        <p>Note that PowerShell, unlike Linux shells, is case-insensitive, so you can just as well write</p>
        <code>test-path $profile</code>
        <p>This cmmdlet works because there is already a path to the profile written into your system - you just might not yet have the profile itself. If it returns false, enter</p>
        <code>New-Item -path $profile -type file</code>
        <p>Now everyone should have a profile file, we can open and edit it with</p>
        <pre><code>
notepad $PROFILE
code $PROFILE # for vscode
atom $PROFILE 
etc.
</code></pre>
        <h3>2. Add a function to your $profile</h3>
        <p>The function we are going to write can be anywhere inside your profile (except within other code). What it does is run two cmmdlets successively. The first one opens a PowerShell instance that has administrator privileges. The second one uses our administrator privileges to reboot you into firmware.</p>
        <p>The first looks like this:</p>
        <code>Start-Process powershell -Verb runAs</code>
        <p>To run it, you might have to press yes on a dialogue box that opens up. The quickest way to do that is to press left arrow then enter.</p>
        <p>The second cmmdlet looks like this:</p>
        <code>shutdown /fw /r /t 0</code>
        <p>/fw means 'firmware', /r 'restart', and /t 0 'after 0 seconds'.</p>
        <p>Our final function looks like this</p>
        <pre><code>
	function boot-fw {
	  Start-Process powershell -Verb runAs -ArgumentList 'shutdown /fw /r /t 0'
	}
</code></pre>
        <p>We feed the second cmmdlet to the first one as a string following -ArgumentList. We then wrap that whole thing in a function, called boot-fw. Best practice is to use verb-noun format to avoid namespace conflicts - but on my own system I broke the rules and went for an even shorter name, fboot. Just put this function anywhere in your $profile and, after opening a new powershell instance, it should be available.</p>
        <p>Now you can type boot-fw to boot into your firmware settings. Or to boot for the win, whatever you like.</p> 
        <p>PROTIP: adding the line Clear-Host to your $PROFILE means that when you open a new PowerShell window you won't see any of Windows' proprietary junk. You might want to check out other things that you can add to the profile, like some (limited) theming.</p>
        <p>Further reading:</p>
        <ul>
<li><a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown">tinker with the shutdown command (Microsoft Docs)</a></li>
<li><a href="https://gist.github.com/timsneath/19867b12eee7fd5af2ba">Someone else's $profile with some useful ideas</a></li>
<li><a href="https://www.howtogeek.com/50236/customizing-your-powershell-profile/">A little bit about theming the PowerShell window</a></li>
<li><a href="https://github.com/felixse/FluentTerminal">A better way to make your PowerShell experience user-friendly</a></li>
</ul>
        <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer of collapsed text">
      </div>
      <h3 class="expandContractButton">Read more +</h3>
    </article>
    <article class="post">
      <span class="post-title-bar"><h2 id="Regex 2: How regular expressions fit into JavaScript" class="post-title">Regex 2: How regular expressions fit into JavaScript</h2><p class="meta-info">10/02/2020<br><a href="./tag-regular-expressions.html">regular expressions</a>, <a href="./tag-fundamentals.html">fundamentals</a>, <a href="./tag-JavaScript.html">JavaScript</a></p></span>
      <div class="post-content">
        <p>Regular expressions, as a system for representing text, are found in most programming languages. In this post, I’m going to focus on JavaScript, which happens to be my favourite programming language (although, it must be said, not for its implementation of regex).</p>
        <h3>1: regular expressions are values</h3>
        <p>In JavaScript regular expressions are a data-type called RegExp. Like most data-types, they can be constructed using literals or an object constructor:</p>
        <pre><code>
‘5’ // a string literal
String(5) // a string created by the constructor function for the string type
</code></pre>
        <p>The syntax for a RegExp literal is to enclose the expression within two forward slashes:</p>
        <code>/(ab){3}/   // a regex matching 3 consecutive ab’s: ababab</code>
        <p>This forward-slash syntax was popularised by Perl, a language which <a href="https://en.wikipedia.org/wiki/Regular_expression#History">did a lot for regular expressions<a>. It is also the most common way to make regular expressions in JavaScript. Since RegExps are not strings, there is no need for any string syntax when creating a RegExp literal. This is different when using the RegExp constructor. Here, we drop the forward slashes, and feed the constructor a string as its argument, leaving it up to the function to make the regular expression for us:</p>
        <code>RegExp(‘(ab){3}’)</code>
        <p>Because regular expressions are objects, they can be:</p>
        <ul>
          <li>Given to functions as arguments</li>
            <code>"123”.match(/2/) // ["2", index: 1, input: "123", groups: undefined]</code>
          <li>Returned from functions</li>
            <code>RegExp(‘a’) // returns a regular expression</code>
          <li>functions can be called on them</li>
            <code>/a/.test(‘a hungry hippo’) // true</code>
        </ul>
        <p>Let’s look in more detail at two functions that work with regular expressions, match() and replace(). Both of these functions are called on strings and take regular expressions as arguments.</p>
        <h3>2: match()</h3>
        <p>match() returns matches it finds. By default, match() returns an object corresponding to the first match it found.</p>
        <pre><code>
let str = “stringy string”
str.match(/[ng]/) // ["n", index: 4, input: "stringy string", groups: undefined]
// square brackets [] mean ‘any of these characters’.
str // “stringy string”
</code></pre>
        <p>However, match really comes into its own when you give the regex the global flag. Then, match returns an array of substrings that match the regex. You give flags to regex literals by adding a letter after the second forward slash, and to regex constructor functions by providing a second argument:</p>
        <pre><code>
let regExOne = /st/g
let regExTwo = RegExp(‘[ng]’, ‘g’)
str.match(regExOne); // [“st”, “st”]
str.match(regExTwo); // [“n”, “g”, “n”, “g”]
</code></pre>
        <h3>3: replace()</h3>
        <p>Next up is replace(), which replaces a substring with another, or multiple substrings with another if you use the global flag. replace() takes two arguments. First, it searches the string on which it was called according to its first argument, a regex. Secondly, it substitutes a match, if it finds one, using its second argument. It does not ‘mutate’ the string it is called on – strings are immutable in JavaScript – but returns a new string.</p>
        <p>When I add articles to this blog, I write them to text files, and then I run a program that I wrote and it compiles HTML for me, ensuring that articles appear in the right place, get added to the archive page automatically, and things like that. I used Ruby to write this program but it could have been done in JavaScript too. It scans a text file called website-template.html, finds a line which says
        <p><code>&lt;!-- INSERT ARTICLES HERE --&gt;</code>,</p>
        <p><em>replaces</em> that line with article content that it got elsewhere, and then writes the new string to a new file - a file just like the one your browser has rendered to let you read this. (Here's the relevant <a href="https://github.com/ievans147/blog/blob/master/resources/modules/writable.rb">Ruby method</a> if you're curious.)</p>
        <p>I could have used string-for-string replacement, like</p>
        <code>webSite = webSite.replace('&lt;!-- INSERT ARTICLES HERE --&gt;', mainContent);</code>
        <p>However, I opted for a regular expression:</p>
        <code>webSite = webSite.replace(/^\s*&lt;!-- INSERT ARTICLES HERE --&gt;/, mainContent);</code>
        </p>This regular expression matches 0 or more whitespace characters from the beginning of the line to the end of &lt;!-- INSERT ARTICLES HERE --&gt.</p> 
        <p>I used regex for three reasons:</p>
        <ol>
  <li>If I used regex, I could allow for a varying amount of whitespace.</li>
  <li>The input was expectable and controllable, so this was a very safe regular expression.</li>
  <li>The Ruby method I used was going to read my string as a regular expression anyway.</li>
</ol>
        <p>Each of these reasons tells us something wider about why and when to use regular expressions.</p>
        <p> A good reason to use them, as discussed in the last article, is that they allow more general matching than one-to-one correspondence. In this case generality solved a specific problem for me: while I knew what I wanted matching lines to say, I didn't want to commit to indenting them some specific amount, because I might change the html template. I also didn't want to only select the comment itself, and not whitespace preceding it on the line, because then when I wrote the new content the first line would have more indentation than other lines. A regex which allowed me to select from the beginning of the line, to a specific match, including an arbitrary amount of whitespace, proved useful.</p>
        <p>It was also a good case for a regex because it was very easy to control. If you want to use regular expressions to sift large and unpredictable data-sets, you will have to think carefully. For instance, it is generally not recommended to use regular expressions to write parsers for programming languages. For less-lofty aims, regular expressions can be useful, but you do need to be careful with them. If you cast your net too wide, you might catch some junk. Once you get beyond syntax, for regex, the crux of the challenge is often striking the right balance between specificity and generality.</p>
        <p>Finally, a good reason to use regular expressions is their prevalence. Regular expressions are <em>everywhere</em>, and so you can count on them as a useful and transferable skill for efficient and sophisticated - but not too sophisticated - text-matching.</p>
        <h3>4: conclusion</h3>
        <p>This marks the end of my brief series on regex. I hope I've equipped you with an appreciation of the usefulness of regular expressions, as well as a grasp of the fundamentals.</p>
        <p>Where to go next</p>
        <ul>
<li><a href="https://www.w3schools.com/jsref/jsref_obj_regexp.asp">A regular expression reference</a></li>
<li>Sites to test regular expressions for <a href="regexr.com">JavaScript</a> and <a href="rubular.com">Ruby</a> (check them both out even if you only know one language)</li>
<li><a href="http://www.zsoltnagy.eu/visualizing-regex-execution-using-finite-state-machines/">Modelling regular expressions as finite-state-machines</a></li>
<li><a href="https://www.codewars.com/collections/regex-31">Some practice problems</a></li>
</ul>
        <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer of collapsed text">
      </div>
      <h3 class="expandContractButton">Read more +</h3>
    </article>
  </main>
  <footer>
    <nav>
      <h3><a class="current-page" href="./index.html">0</a></h3>
      <h3><a class="non-current-page" href="./index-1.html">1</a></h3>
    </nav>
    <nav>
      <h3><a href="./index.html">Home</a></h3>
      <h3><a href="./archive.html">Archives</a></h3>
      <h3><a href="./about.html">About</a></h3>
      <h3><a href="https://github.com/ievans147/blog" target="_blank">Source code</a></h3>
    </nav>
  </footer>
  <script src="resources/text-expander.js"></script>
</body>
</html>