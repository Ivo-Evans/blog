<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="resources/style.css">
  <title>A Bit Wise blog</title>
</head>
<body>
  <header>
    <h1><a href="./index.html">A Bit Wise</a></h1>
    <h2>A blog about the basics</h2>
  </header>
  <div class="border-total"><div class=border-substance></div></div>
<aside>
  <nav>
    <h3>tags</h3>
    <p><a href="./tag-fundamentals.html">fundamentals</a></p>
    <p><a href="./tag-operators.html">operators</a></p>
    <p><a href="./tag-JavaScript.html">JavaScript</a></p>
    <p><a href="./tag-autoboxing.html">autoboxing</a></p>
    <p><a href="./tag-objects.html">objects</a></p>
    <p><a href="./tag-prototypes.html">prototypes</a></p>
    <p><a href="./tag-evaluation-strategy.html">evaluation strategy</a></p>
    <p><a href="./tag-call-by-sharing.html">call by sharing</a></p>
    <p><a href="./tag-call-by-value.html">call by value</a></p>
    <p><a href="./tag-call-by-reference.html">call by reference</a></p>
    <p><a href="./tag-data-types.html">data types</a></p>
    <p><a href="./tag-logic.html">logic</a></p>
    <p><a href="./tag-conditionals.html">conditionals</a></p>
    <p><a href="./tag-PowerShell.html">PowerShell</a></p>
    <p><a href="./tag-tips.html">tips</a></p>
    <p><a href="./tag-boot-order.html">boot order</a></p>
    <p><a href="./tag-dual-boot.html">dual-boot</a></p>
    <p><a href="./tag-windows.html">windows</a></p>
    <p><a href="./tag-regular-expressions.html">regular expressions</a></p>
  </nav>
</aside>
  <main>
<article class="post">
  <span class="post-title-bar">
    <h2 id="The . (dot access) operator" class="post-title">
      The . (dot access) operator
    </h2>
    <p class="meta-info">
      27/02/2020<br>
      <a href="./tag-fundamentals.html">fundamentals</a>, <a href="./tag-operators.html">operators</a>, <a href="./tag-JavaScript.html">JavaScript</a>, <a href="./tag-autoboxing.html">autoboxing</a>, <a href="./tag-objects.html">objects</a>, <a href="./tag-prototypes.html">prototypes</a>
    </p>
  </span>
  <div class="post-content">
    <p>TESTThis is one we see all over the place, when calling functions or getting properties of objects, but often without
  really understanding it. It’s pretty simple, but we’ll first have to do a primer on data-types.</p>
<h3>1. Primitives and reference types</h3>
<p>In JavaScript there are a number of primitive types, and one (yes – one) reference type. Primitives include:</p>
<ul>
  <li>numbers</li>
  <li>strings</li>
  <li>boolean</li>
  <li>undefined</li>
  <li>null</li>
  <li>symbols</li>
</ul>
<p>All other values – arrays, objects, functions, RegExps etc., are reference types.</p>
<p>Amongst the reference types, one type is king: the object.</p>
<p>An object is a collection of key-value pairs, where the key is a symbol and the value can be anything.</p>
<p>When constructed using a literal, you use curly-braces, colons and commas:</p>
<code><pre>
let theKing = {
  firstName: ‘Elvis’,
  objectivelyBestSong: ‘Blue Moon’
}
</pre></code>
<p>The object is king among the reference types because all the other reference types are technically kinds of objects.
  For instance, an array is an object that uses numbers for its keys.</p>
<p>You can look up the properties of an object in two ways:</p>
<code><pre>
theKing.firstName // ‘Elvis’
theKing[‘objectivelyBestSong’] // ‘Blue Moon’
</pre></code>
<p>If you write one of your own objects, like our theKing object, you can use either syntax, where the latter takes
  strings, and so can be programmatically specified. However, for other objects, you cannot always use both forms. For
  instance, you cannot use the dot notation to look up an array item by index, because numbers are not valid <a
    href="https://developer.mozilla.org/en-US/docs/Glossary/identifier">identifiers</a>.</p>
<code><pre>
[1, 2, 3][2]; // 3
</pre></code>
<h3>2. The dot operator always indicates object-property lookup</h3>
<p>Whenever you see the dot operator, it is being used to look up the properties of an object. Thus, when you see</p>
<code><pre>
[1, 2, 3, 4].length // 4
</pre></code>
<p>you are accessing the length property of the array.</p>
<p>This is exactly the same with function – or really, we should say <em>method</em> – calls:</p>
<code><pre>
3.toString() // ‘3’
[1, 2, 3].map(x => x * 2) // [2, 4, 6]
</pre></code>
<h3>3. If objects are different to primitives and only objects have properties, how can we look up the properties of
  primitives?</h3>
<p>This is a good question. Above, we called the function toString() on a number. But a number is a primitive, not a
  reference type, so how could it have key-value pairs? Similarly, in the documentation (by which I mean MDN pages – if
  this article is at your level, I don't recommend reading <a
    href="https://www.ecma-international.org/ecma-262/7.0/">the official ECMA spec</a>) we often find methods like</p>
<code><pre>
Number.toString()
</pre></code>
<p>‘Number’ is a <a href="https://css-tricks.com/understanding-javascript-constructors/">constructor function</a>.
  Functions are a kind of reference value. Whenever we see a function with this syntax in the documentation, we can call
  it on specific values that would be created by the constructor function, like 3 could be constructed by Number('3').
  It is <em>through</em> the Number function that 3 gets access to the toString() function. If we take a look at the
  Number function by just typing Number into our browser dev tools and hitting enter, we can see that one of its
  properties is prototype: Number, one this property's properties is prototype: Object, and that one of <em>this</em>
  property's properties is function: toString(). So how is it that we can access the properties of the Number
  constructor function as properties of specific numbers, like 3, which are not supposed to have properties because
  numbers are primitives?</p>
<p>The answer is that JavaScript does some sleight of hand, to make things work, called <strong>autoboxing.</strong></p>
<p>Autoboxing is exactly what it sounds like, and its pretty simple: when you try to use a primitive like an object, the
  JavaScript engine temporarily wraps the primitive in an object and then accesses the properties of that object. After
  it's done, it marks the object as ready for garbage collection.</p>
<p>Because of autoboxing, when you try to reassign the value of a primitive that has a prototype, JavaScript does not
  throw an error but just seems to ignore you, while when you try to reassign the value of a primitive that does not
  have a prototype, JavaScript throws an error:</p>
<code><pre>
let str = “string”;
let na = null;
str[6] = “s”;
str; // “string”
str.lastIndex = str.length - 1;
str.lastIndex; // undefined
na.newProperty = “impossible”
// Uncaught TypeError: Cannot set property 'newProp' of null
  	at &lt;anonymous&gt;: 
</pre></code>
<p>The string, unlike null, is autoboxed. When you assign properties to it, you are assigning properties to its
  temporary wrapper object. However, because that wrapper object is temporary, those properties are not saved. null is
  not wrapped at all, so there is nothing to access with the dot operator and the JavaScript engine throws an error.</p>
<p>So that’s it – the dot access operator is <em>always</em> looking at the property of an object – but what counts as
  an object sometimes shifts in order to accommodate convenient dot access.</p>

    <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer" />
  </div>
  <h3 class="expandContractButton">Read more +</h3>
</article>
<article class="post">
  <span class="post-title-bar">
    <h2 id="Assignment and value identity" class="post-title">
      Assignment and value identity
    </h2>
    <p class="meta-info">
      25/02/2020<br>
      <a href="./tag-operators.html">operators</a>, <a href="./tag-JavaScript.html">JavaScript</a>, <a href="./tag-evaluation-strategy.html">evaluation strategy</a>, <a href="./tag-call-by-sharing.html">call by sharing</a>, <a href="./tag-call-by-value.html">call by value</a>, <a href="./tag-call-by-reference.html">call by reference</a>, <a href="./tag-data-types.html">data types</a>
    </p>
  </span>
  <div class="post-content">
    <p>When I started to program I didn’t really think about what the references of my variables ‘were’ - they were just what I saw when I called functions like console.log(). Well, it’s not quite so simple, and understanding how variables refer will pay dividends.</p>
<h3>Question 1.0</h3>
<p>When we assign the same value to two variables, as in</p>
<code><pre>
let a = 1;
let b = 1;
</pre></code>
<p>or</p>
<code><pre>
let c = [];
let d = [];
</pre></code>
are we assigning two names that point to the same value, or are we creating two identical values?
<h3>Answer 1.0</h3>
<p>We are creating two identical, but different values</p>
<p>It can be hard to realise this, because, as JavaScript programmers, our comparison operators can sometimes feel unreliable and confusing. For instance</p>
<code><pre>
a === b; // true
c === d; // false
</pre></code>
<p>When I first encountered this result, I found it bewildering and aggravating. But I hope that, by the end of the article, I will have convinced you that you would not want the equality operators to behave any other way. This is not part of the byzantine system of type conversion for which JavaScript is so infamous.</p>
<p>Let's ask another question.</p>
<h3>Question 2.0</h3>
<p>When you assign one variable to another, as in</p>
<code><pre>
let e = 1;
let f = e;
</pre></code>
<p>or</p>
<code><pre>
let g = [];
let h = g;
</pre></code>
<p>are you assigning two names that point to the same value, or are you assigning two names to different values?</p>
<h3>Answer 2.0</h3>
<p>The answer to this question is this:</p>
<blockquote>It depends on the data type, but, because of the mutable/immutable distinction between data types, you can understand 99% of cases by thinking about assignment operators as adding names to values rather than creating values.</blockquote>
<p>Let's dig deeper</p>
<h3>Data-types: a primer</h3>
<p>In JavaScript every value is of either a primitive or a reference type. Primitive values are basic and ‘immutable’ - they cannot be changed. They include:</p>
<ul>
  <li>Number</li>
  <li>String</li>
  <li>Boolean</li>
  <li>null and undefined</li>
</ul>
<p>Reference types, on the other hand, can <em>include</em> primitives, and they are mutable. They include:</p>
<ul>
  <li>Object</li>
  <li>Array</li>
  <li>Function</li>
</ul>
<h3>Mutating the assigned value</h3>
<p>Now we are ready to see why we can afford to see the assignment operator as an operator which points a name to a pre-existing value, rather than something which saves new values to new memory locations. Let's set up our example:</p>
<code><pre>
let primitiveParent = 1;
let primitiveChild = primitiveParent;
let referenceParent = []
let referenceChild = referenceParent;
</pre></code>
<p>Since primitives are immutable, there is no way that we could update primitiveParent without simply reassigning its value. The 1 referred to by primitiveParent is at a specific place in memory, and it is read-only, so we cannot edit that place ourselves. If we want to change the value of the variable which points to that part of your computer’s memory, we will have to simply reassign:</p>
<code><pre>
primitiveParent = 2;
primitiveParent; // 2
primitiveChild; // 1
</pre></code>
<p>Note that everything I say in this article is equally true for other kinds of assignment operator, like ++, the postfix increment. We could also have done</p>
<code><pre>
primitiveParent++;
primitiveParent; // 2
primitiveChild; // 1
</pre></code>
<p>Here, we assign a new value to primitiveParent.</p>
<p>Reference types are superficially similar. Just like with primitives, if we call the assignment operator on the reference type itself, we will simply assign a new value to the variable, discarding the old one:</p>
<code><pre>
referenceParent = [1];
referenceParent; // [1];
referenceChild; // []
</pre></code>
<p>But the difference is that reference types can me modified by means other than calling assignment on them. For instance, we can use the square-bracket lookup to modify an array at a specific index:</p>
<code><pre>
referenceChild = referenceParent; // both are [1] at this point
referenceParent[0] = 200;
referenceParent; // 200
referenceChild; // 200
</pre></code>
<p>What’s really important to note, here, is that we haven’t used the assignment operator on referenceParent at all. First, we used another operator, the square bracket lookup, and then we called an assignment operator on the square bracket lookup’s return value.</p>
<p>Assignment always causes its left-hand-side to point at a <em>new</em> value. It is just that, sometimes, that value is <em>mutable</em>, and it can be changed by other means, while sometimes it is immutable.</p>
<h3>Tracking mutable values</h3>
<p>Earlier I promised you that I would shed light on the strange behaviour of == and ===</p>
<code><pre>
1 === 1; // true
[] === []; // false
</pre></code>
<p>Well, now is the time to make my pitch.</p>
<p>Because reference values are mutable, when we compare them, we are interested in what they really are; we want to have some way of tracking their histories beyond their superficial properties. Recently I made a JavaScript game in which you are a cowboy with two revolvers. Each revolver had an object containing various kinds of information, but at many points in the game, the two revolvers could plausibly look alike. I wanted to be able to call functions to do things like reloading and know which revolver had been passed into the function. I could use the equality operators to check which revolver object I actually had.</p>
<p>In this case I could, it's true, have just added another property to each gun to indicate which gun it was. But we can imagine situations when that isn't practical, like when comparing two arrays which are unpredictably mutated during the execution of the program.</p>
<p>When it comes to primitives there’s no need for this level of comparison. Because they are immutable, the only thing we will realistically want to compare primitives for is their equivalence, and so, for primitives, this is what the equality operators test. An operator which returned false for two equivalent numbers in different places in memory would <em>always</em> return false, because when you use a literal or assign a number to a variable, a new number is created in memory.</p>
<p>That said, I would definitely appreciate an equivalence operator for reference types. <a href="https://lodash.com/docs/#isEqual">Lodash</a> has a function for this, if you want to go that route.</p>
<h3>Assignment without the assignment operator: function parameters</h3>
<p>We are almost done. Next, we should note that functions parameters and arguments work like variables declared with let or var and the assignment operator.</p>
<p>A function <em>argument</em> is the value you give to the function when you call it, and a <em>parameter</em> is the name that the function uses, internally, to represent the argument.</p>
<pre><code>
function myFunction(myParam) {
  return myParam;
}
let myArgument = 5;
myFunction(myArgument)
</code></pre>
<p>Parameters and arguments are often conflated, but they are not the same thing. The relationship between parameter and argument is the same as the relationship between a let variable and its reference.</p>
<p>If parameter is to argument as variable is to reference, the rules we discussed above apply here too:</p>
<pre><code>
let a = [1];
function sideEffector(param) {
  param[0] *= 1000;
return “something irrelevant”; 
}
</code></pre>
<pre><code>
sideEffector(a);
// “something irrelevant”
a;
//[1000]
</code></pre>
<p>What you see above is an anti-pattern: coding like this will lead to problems. So beware!</p>
<h3>What's the other 1%?</h3>
<p>I said we could understand 99% of cases by thinking of the assignment operator as an operator which points names to values, rather than creating values for assignment, even though this isn’t always how it actually works. So what’s the other 1%?</p>
<p>Basically, for primitives, assignment does actually copy a new primitive value to a new location in memory:</p>
<code><pre>
let x = 10;
let y = 10;
// there are two different, immutable 10 values in memory
</pre></code>
<p>This typically isn’t a problem, because encoding 10 in memory is not very costly. If you have a very large piece of data, it will often be very large <em>because</em> it is a reference type composed of many smaller primitives. But if you have a very large primitive, it would be good to know that JavaScript uses a call-by-value evaluation strategy for primitives, but a call-by-sharing strategy in general.</p>
<p>An evaluation strategy is a strategy for handling how function arguments are treated when they are passed into functions, and how values are treated when they are assigned to variables. A lot of false information has been published about this topic because, while the two most well-known strategies are call-by-value and call-by-reference, JavaScript, Ruby, Python and other languages actually use a lesser-known compromise strategy called call-by-sharing or call-by-object-sharing.</p>
<p>In call-by-value, when you pass a value to a function, it is replicated. This ensures that all functions are ‘pure’ – they do not modify outside values, only take one value and return another. Call-by-value is great for debugging and code cleanliness; however, it is computationally costly, because you have to constantly reproduce values. This is fine for simple operations, but if you’re trying to sequence the human genome, call-by-value won’t cut it.</p>
<p>Call-by-reference represents an alternative approach. In call by reference, what is passed is the reference of the value. So if you give a function a variable as an argument, and then you reassign the variable inside the function, this will mutate the variable itself. Note that I’m talking about reassignment, not mutation. Call-by-reference has its own problems though when you have a convoluted chain of references to a single value: it is easy to introduce bugs by mutating it accidentally. As far as I know, no serious language implements call-by-reference by default.</p>
  <figure>
    
    <img src="./resources/content-images/evaluation-strategies/call-by-value.PNG" alt="call by value">
    <figcaption>
      The pseudocode to get you here:
      <code><pre>
variableOne = [0, '2']
variableTwo = variableOne
      </pre></code>
    </figcaption>
  </figure>
  <figure>
    
    <img src="./resources/content-images/evaluation-strategies/call-by-reference.PNG" alt="call by reference">
    <figcaption>
      The pseudocode to get you here:
      <code><pre>
variableOne = [0, '2']
variableTwo = variableOne
      </pre></code>
    </figcaption>
  </figure>
<p>Call-by-sharing limits call-by-reference slightly. In call-by-sharing, when you assign a variable to another, as in</p>
<code><pre>
let a = [1];
let b = a;
</pre></code>
<p>you are assigning the address saved to a to b. Therefore, if you reassign – again, note that I’m saying reassign, not mutate – a, b will still point to the array that a originally pointed to. In call-by-reference, by contrast, b would be tightly bound to a. Call-by-sharing also incorporates, as we saw at the opening of this section, a call-by-value strategy for primitives. In the code</p>
<code><pre>
let c = 10;
let d = c;
</pre></code>
<p>the value 10 has been saved to two different locations in memory.</p>
  <figure>
    
    <img src="./resources/content-images/evaluation-strategies/call-by-sharing-reference.PNG" alt="call by sharing for reference values">
    <figcaption>
      In call by sharing, values <em>share</em> access to the object.
      <code><pre>
variableOne = [0, '2']
variableTwo = variableOne
      </pre></code>
    </figcaption>
  </figure>
  <figure>
    
    <img src="./resources/content-images/evaluation-strategies/call-by-sharing-primitive.PNG" alt="call by sharing for primitive values">
    <figcaption>
      These values would be <a href="https://en.wikipedia.org/wiki/Object_type_(object-oriented_programming)">boxed</a> and that's why they're separate.
      <code><pre>
variableOne = "1010"
variableTwo = variableOne;
      </pre></code>
    </figcaption>
  </figure>
<p>That's it! I hope I helped. Even if you only read parts of this article, it should still be useful.</p>
<p>Further reading:</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">call by sharing on Wikipedia</a></li>
  <li><a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-assignment-operators">The ECMA spec on the assignment operator</a></li>
  <li>This <b><a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/">blog post</a></b> is better than most.</li>
</ul>
    <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer" />
  </div>
  <h3 class="expandContractButton">Read more +</h3>
</article>
<article class="post">
  <span class="post-title-bar">
    <h2 id="|| and &&" class="post-title">
      || and &&
    </h2>
    <p class="meta-info">
      20/03/2020<br>
      <a href="./tag-operators.html">operators</a>, <a href="./tag-fundamentals.html">fundamentals</a>, <a href="./tag-JavaScript.html">JavaScript</a>, <a href="./tag-logic.html">logic</a>, <a href="./tag-conditionals.html">conditionals</a>
    </p>
  </span>
  <div class="post-content">
    <p>Logic in programming does not map directly onto logic itself. This is fair enough. Logicians aren’t even sure, themselves, what logic is, while computers have to actually work. This means that logic in programming is something that one must learn about. When I first started programming, I lacked a clear and explicit guide and I found myself confused.</p>
<p>One thing that surprised me was that the logical connectors || and && could both return values other than true and false. Another thing that surprised me was the way that logic used what’s called short-circuit evaluation. A third thing that surprised me was that you could combine these two facts to make || and && statements into conditional, i.e. if-then, statements. But before we get into any of that, we should give a short description of || and &&.</p>
<h3>1. || and && 101</h3>
<p>|| is an ‘or’ operator and && is an ‘and’ operator. They each have an arity of two – they take two operands, one on each side, and return a value which represents the logical relationship between their two operands.</p>
<p>We typically represent these logical relationships with truth tables. Logic is taken to be bivalent: it only has two values, true or false – there is no third value, like ‘half true’ or ‘true in the right context’:</p>
<div class="parallel-code">
<table>
  <tr>
    <th>true</th>
    <th>||</th>
    <th>true</th>
    <th>is...</th>
    <th>true</th>
  </tr>
  <tr>
    <th>true</th>
    <th>||</th>
    <th>false</th>
    <th>is...</th>
    <th>true</th>
  </tr>
  <tr>
    <th>false</th>
    <th>||</th>
    <th>false</th>
    <th>is...</th>
    <th>false</th>
  </tr>
  <tr>
    <th>false</th>
    <th>||</th>
    <th>true</th>
    <th>is...</th>
    <th>true</th>
  </tr>
</table>
<table>
  <tr>
    <th>true</th>
    <th>&&</th>
    <th>true</th>
    <th>is...</th>
    <th>true</th>
  </tr>
  <tr>
    <th>true</th>
    <th>&&</th>
    <th>false</th>
    <th>is...</th>
    <th>false</th>
  </tr>
  <tr>
    <th>false</th>
    <th>&&</th>
    <th>false</th>
    <th>is...</th>
    <th>false</th>
  </tr>
  <tr>
    <th>false</th>
    <th>&&</th>
    <th>true</th>
    <th>is...</th>
    <th>false</th>
  </tr>
</table>
</div>
<p>Let’s imagine that we have three variables, isInLondon, isLearningToProgram and isAMasterPrgrommaer.</p>
<code><pre>
let isInLondon = true;
let isLearningToProgram = true;
let isAMasterProgrammer = false;
</pre></code>
<p>We can feed these variables to || and && for idiomatic assessments of logical relationships:</p>
<code><pre>
isInLondon && isLearningToProgram // true
isLearningToProgram || isAMasterProgrammer // true
isLearningToProgram && isAMasterProgrammer // false
</pre></code>
<p>Note that || is ‘nonexclusive’:</p>
<code><pre>
isInLondon || isLearningToProgram // true
</pre></code>
<p>For this reason, || and && are inverse operators – each of them returns one value in three cases, and the other in one case. We could also implement an exclusive or (XOR), if we wanted to, in which the above logical statement would come out false. However, the XOR is less important in programming and in logic in general. We'll skip over it for now.</p>
<h3>2. true v.s. truthy, false v.s. falsy</h3>
<p>When we’re programming, we give more values than true and false to the logical operators. How does this work?</p>
<p>It’s not quite like when you use logic in conversation. In conversation, like when you say ‘he is at home and eating dinner’, you feed the logical assertion two statements, sub in each statement for its truth-value at time of evaluation, and you see whether the whole expression is true. If it is, then the logical statement – an assertion of a logical relationship – is true and so should return a truth value.</p>
<p>In JavaScript it's a bit different. Look at this code:</p>
<code><pre>
"He's a master programmer" || "He's a whale" // "He's a master programmer"
"He's a whale" || "He's a master programmer" // "He's a whale"
"" || "He's a whale" // "He's a whale"
"He's a whale" || "" // "He's a whale"
</pre></code>
<p>Alas the computer, on balance, seems sure that I am a whale. But how does it <em>get</em> to that conclusion? It is not, I am afraid to say, to do with the important question of whether I am a master programmer or a whale.</p>
<p>This is because the computational notion of truth is somewhat divorced from the everyday one. For a computer, the question 'is it true?' is more like 'yes or no?' than 'is it an accurate representation of reality?' Computers were designed from the hardware up, and, at a basic level, they are collections of transistors which are either firing or not firing. Boolean logic, which was already a developed academic field, let the creators of modern computing use these two states - electricity or a lack of electricity - to represent information. True is represented, on a fundamental level, by a firing transistor, and false by a non-firing transistor. 1 and 0 can be used to the same effect as true and false - the symbol used does not matter, as long as the symbols are <em>binary</em> - that is, they let us represent two states.</p>
<p>JavaScript has moved on from using single transistors to represent truth values. In JavaScript, there are various kinds of value, and they can <em>all</em> be used in logical operations, even though they are not true or false <em>per se</em>. But what we can learn from the foundations of computing is that computational notions of true and false are not really about truth or falsity - the degree to which a representation is accurate - at all. The creators of programming languages have to make more or less arbitrary decisions about what values should behave like they're true, and what values should behave like they're false. The values which behave like they're true, whether or not they are the value true themselves, are called <em>truthy</em> values. The values that behave like they're false, whether or not they are the value false themselves, are called <em>falsy</em> values.</p>
  
<p>A truthy or falsy value can, at any time, do the job of true and false when used in logic, either as the input to or output from a logical operation, because they are temporarily coerced by the operator into Booleans.</p>
<p>So how can we tell what values are truthy, and what falsy? It's pretty easy. Almost every value is truthy, and there are only seven falsy values:</p>
<ul>
 <li>false</li>
 <li>0 and 0n</li>
 <li>empty strings</li>
 <li>undefined, null and NaN</li>
</ul>
<p>(Note, though, that there is some <a href="https://github.com/denysdovhan/wtfjs#-is-truthy-but-not-true">funny business</a> about empty arrays and null.)</p>

<p>Now we can see how the computer realised that I'm a whale dressed as a human, and that I'm not a master programmer: In the first line of code above, || receives two truthy strings, and outputs a truthy string; in the third line of code above, || receives a truthy and falsy string, and outputs a truthy string. It's okay to output strings, rather than true or false, because the output of the operation is just as truthy/falsy as the input. Consulting our truth tables from earlier, then, we can see that the operations have logically valid output.</p>
<h3>3. Short-circuit evaluation</h3>
<p>So, || and && don’t return truth values, but rather their left-hand-side (LHS) or right-hand-side (RHS) - two terms that will be cropping up a lot from here on. How do || and && decide which side to return, when they could return either of two?</p> 
<p>Programming languages, by convention, check first the LHS and then the RHS. Sometimes, after the first result, the conclusion is determined. For instance, in the statement:</p>
<code><pre>
LHS && RHS
</pre></code>
<p>if LHS is falsy, then, no matter what RHS is, the and-statement, as a whole, must be false. The computer can save time by just ceasing it’s evaluation after it finds LHS to be false. If it finds LHS to be true, it needs to proceed to RHS; if RHS is true, the and-statement is true, and if it is false then, even though LHS is true, the and-statement is false. Either way, though, if LHS is true the truth of the and-statement rests entirely on RHS.</p>
<p>The converse holds for || statements:</p>
<code><pre>
LHS && RHS
</pre></code>
<p>If LHS is true, then, by fiat, the or-statement is true. However, if LHS is false, we still need to check RHS. If it is true, the statement passes, but if it is false, the statement fails.</p>
<p>Since || and && statements do not return truth values, but either the LHS or RHS, in</p>
<code><pre>
LHS && RHS
</pre></code>
<p>if LHS is false, we can return that; else, if LHS is true, we will return RHS. We don't even need to check whether RHS is truty or falsy; whatever it is, it will be logically valid. In</p>
<code><pre>
LHS || RHS
</pre></code>
<p>if LHS is true, we can return that; else, if LHS is false, we will return RHS.</p>
<p>This is short-circuit evaluation. It is a simple, elegant and – dare I say it –  a logical solution. There is no need to compute  a third value (true or false) which represents the operator’s decision. It is guaranteed that we can repurpose one of the inputs, and that we will repurpose the leftmost appropriate input.</p>
<p>Now, before we close off this section, we should think a little about the consequences of returning truthy and falsy values instead of true and false. Because we can rely on the explicit rules of short-circuit evaluation, we can use logic to do things like decide on our variable assignments for us:</p>
<code><pre>
let a = 1
let b = “”
let c = a && b
c // “”
</pre></code>
<h3>4. || and && and conditional logic</h3>
<p>So far, we’ve covered the meaning of short-circuit evaluation and truthiness and falsiness for || and &&. But these are not the only logical operations we do when programming. One other thing we do is express conditional logic, logic which expresses if-then relationships. Such conditional logic, sometimes called flow-control, lets us establish branching possibilities within our programs.</p>
<p>The most common kind of conditional statements are if statements, if-else statements, and if-else if -else statements (two if-else statements stuck together). First let’s look at an if statement:</p>
<code><pre>
let a = 5;
if (a) {
  console.log(‘a is true’);
}
</pre></code>
<p>Notice that in this statement, we do not need to say if (a == true). a’s truthiness is enough for the logic to execute.</p>
<p>Sometimes we do want to use operators on values to generate new boolean values, as in this if-else if-else statement, where the < operator is used:</p>
<code><pre>
if (a < 10) {
  console.log(‘less than ten’);
} else if (a < 50) {
  console.log(‘less than fifty’);
} else {
  console.log(‘wow a must be really big”);
}
</pre></code>
<p>The output of this code is ‘less than ten’, even though, of course, a is less than fifty. What we see here is a chain of logic that has the same effect as short-circuit evaluation. The second condition, if (a < 50), is itself dependent on the falsity of the first condition, because it is attached to the first condition’s else statement. The second condition is effectively</p>
<code><pre>
if (!(a < 10)) && (a < 50)
</pre></code>
<p>Because of this, after the program satisfies that first condition, (a < 10), it simply stops looking at the other conditions, which are premised on the falsity of earlier conditions. To print both conditions, we could attach them to separate if statements, rather than premising later if statements on the else statements of earlier if statements.</p>
<p>So we can see that conditional logic effectively short-circuits, and we saw earlier that || and && statements short-circuit too. This similarity cuts deep: it lets us use || and && to make conditional statements, and conditional statements to make || and && statements.</p>
<p>Here are || and && implemented as functions that use conditional logic:</p>
<code><pre>
  function or(leftHandSide, rightHandSide) {
    if (leftHandSide) {
      return leftHandSide;
    } else {
      return rightHandSide; 
    }
  }
</pre></code>
<code><pre>
  function and(leftHandSide, rightHandSide) {
    if (leftHandSide) {
      return rightHandSide;
      } else {
      return leftHandSide;
      }
  }      
</pre></code>      
<p>There’s a nice kind of symmetry here: the only difference between the two functions is what the truthiness of the LHS indicates. In the or function, it indicates that evaluation can stop. In the and function it indicates that evaluation must continue.</p>
<p>We can implement a converse kind of functionality with || and && operators.</p>
<code><pre>
  function ifThen(antecedent, consequent) {
    return antecedent && consequent;
  }
</pre></code>
<code><pre>
  function ifNotThen(antecedent, consequent) {
    return antecedent || consequent;
  }  
</pre></code>      
<p>I’ve introduced two new terms here, ‘antecedent’ and ‘consequent’. These just mean ‘the bit that comes before’ and ‘the bit that comes after’ in a conditional statement. In the statement ‘if I go to Alaska, I will fulfill a lifelong ambition’, ‘I go to Alaska’ is the antecedent, and ‘I will fulfill a lifelong ambition’ is the consequent.</p>
<p>The two functions above are not that practical. But using the logical operators && and || to express conditions can be practical. Let’s take a realistic example, trying to parse a string and return an array that contains any numbers inside the string. Given the string:</p>
<code><pre>
	‘1 2 ,4 &:\ 301’
</pre></code>
<p>we should return</p>
  
<code><pre>
	[‘1’, ‘2’, ‘4’, ‘301’]
</pre></code>
<p>To achieve this, we will use the match() function and feed match() a regex.  Our regex will look like this:</p>
<code><pre>
	/[0-9]+/g
</pre></code>
<p>[0-9] represents any character 0..9. The plus symbol means ‘one or more of what I preceded’ - [0-9]. The g is a flag which means global, and tells match() to return more than one match.</p>
<p>We’re all set up, and writing this function should be simple enough.</p>
<p>However, there is a hitch. A requirement of our function is that it returns an array, even if the array is empty. But match() has an idiosyncrasy: if it finds no matches, it doesn’t return an empty array or an empty string, but returns null.</p>
<p>How are we to solve the problem? Recall that null is falsy. We can use this to our advantage with some conditional logic.</p>
<code><pre>
  function findNumbers(string) {
  let result = string.match(/[0-9]+/g);
  if (result) {
   return result;
  } else {
    return [];
}
</pre></code>
<p>This is all right, but it’s quite long. We can shorten the same logic with the ternary operator, a quick way to write if-else statements:</p>
<code><pre>
  function findNumbers(string) {
  let result = string.match(/[0-9]+/g);
  return result ? result : [];
  // if result is truthy, return result, else, return []
}
</pre></code>
<p>This is good. However, we can do even better with the || operator:</p>
<code><pre>
  function findNumbers(string) {
  return string.match(/[0-9]+/g) || [];
}
</pre></code>
<p>And this is where using || for conditional logic really shines.</p>
<p>Of course, you should not always use || and &&. If you want to use multiple consequents, you should opt for the full-fledged if(){} else{} structure. And even for more compact if-else conditions, rather than if-then or if-not-then, the ternary operator is generally preferable.</p>
<p>However, if what you want to say is ‘if a then b, else a’, or ‘if not a then b, else a’ - in other words, if you want to choose between two operands - consider using a && b or a || b. And remember, logic in programming doesn't really bear much of a relation to logic, or to truth and falsity - it's just an arbitrary set of rules for the transformation of data. </p>
    <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer" />
  </div>
  <h3 class="expandContractButton">Read more +</h3>
</article>
<article class="post">
  <span class="post-title-bar">
    <h2 id="How to talk about operators" class="post-title">
      How to talk about operators
    </h2>
    <p class="meta-info">
      17/02/2020<br>
      <a href="./tag-operators.html">operators</a>, <a href="./tag-fundamentals.html">fundamentals</a>, <a href="./tag-JavaScript.html">JavaScript</a>
    </p>
  </span>
  <div class="post-content">
    <p>It doesn't need to be an awkward discussion. All we need is some simple <strong>vocabulary</strong></p>
<h3>1. Arity</h3>
<p>An operator’s arity is the number of arguments – also called operands – that it takes. For instance, comparison operators have an arity of two – they take two operands:</p>
<pre><code>
	// true
	5 < 10
</code></pre>
<p>Here, 5 is one operand and 10 is another.</p>
<p>An arity of two is the most common arity in JavaScript. Some operators have an arity of 1:</p>
<pre><code>
	!false
	// true
	typeof true
	// boolean
</code></pre>
<p>One operator has an arity of three, the ternary operator. Ternary means 'composed of three parts' and the ternary operator is used to express conditional logic:</p>
<pre><code>
	condition ? true : false
</code></pre>
<p>The first operand, the bit to the left of the ?, is a condition to be evaluated. If it is evaluated to true, then the second operand, the bit in between ? and :, is executed. If the first operand is evaluated to false,  the third operand, the bit after :, is executed.</p>
<pre><code>
	let iAmIvo = true;
	function amIIvo(bool) {
	  return bool ? ‘yup’ : ‘no’;
	}
	amIIvo(iAmIvo); // ‘yup’
</code></pre>
<h3>2. Associativity</h3>
<p>Next up is an operator’s associativity. This isn’t about how operators interact with each other (that’s precedence) but about how operands interact with each other and with the operator. Basically it is the direction in which operands are evaluated. It can be either right-to-left or left-to-right. When an operator is left-to-right associative, we sometimes say that it is left-associative, and when it is right-to-left associative, we sometimes say that it is right associative.</p>
<p>Mathematical and logical operators are left-to-right associative:</p>
<pre><code>
	10 – 5 // 5
	true || false // true
</code></pre>
<p>The ternary operator is left-associative too:</p>
<pre><code>
	condition ? ‘true’ : ‘false’
</code></pre>
<p>Assignment, on the other hand, is right-to-left associative:</p>
<pre><code>
	let a = 1;
	let b = 2;
	let c = a;
	c; // 1 
</code></pre>
<p>Unary operators - operators with an arity of 1 - tend to be right-associative:</p>
<pre><code>
	!false
	// true	
	typeof Object
	// “function”
</code></pre>
<h3>3. Precedence</h3>
<p>A function’s precedence expresses where it stands in relation to other operators. If it has a high precedence, it is evaluated early. This means that it has first dibs on its operands. If it has low precedence, it is evaluated later. It receives only the operands that other operators didn’t want, or have already processed.</p>
<p>Look at this mathematical expression:</p>
<pre><code>
	1 * (0 – 1) === 1 * 0 – 1
	// true
</code></pre>
<p>Since it returns true, we can tell that the logical comparison operator === has lower precedence than the numerical operators. If it had high precedence – first dibs – it would compare (0 – 1) with (1), and find them nonequal. However, in actuality it compares -1 with -1 and finds them equal.</p>
<h3>4. Putting it all together</h3>
<p>Putting it all together, we can now explain exactly why compound expressions work like they do. Let's take an example:</p>
<pre><code>
a > b && a > c || !(a || c) ? 'something' : 'something else';
</code></pre>
<p>There's some relatively thorny logic here that could do with some unpicking. We can use the terms we just learned to uncover the secrets of the expression. As we go along, I'll tell you the relative values of operators, but there's also a link to a comparison table at the end of this article.</p>
<p>The operator with the highest precedence here is the grouping operator, aka the parentheses (), so we evaluate these first. Inside we find a || c, so we evaluate that.</p>
<p>The operator with the next highest precedence is the logical not operator !, so we flip whatever we got from the parentheses</p>
<p>This is actually an application of De Morgan's law, which states, basically, that</p>
<code><pre>
!(a || b) == !a && !b;
!(a && b) == !a || !b;
</pre></code>
<p>The operator with the next highest precedence is the greater-than operator >. There are two of those, so we evaluate first the left-hand one and then the right-hand one. Each of them will return a truth value.</p>
<p>The next highest precedence is &&; the last operation returned two truth values on either side of it, so we feed those to && to receive a boolean.</p>
<p>next we have ||, which is lower than &&. After evakuating that, we are finally ready to evaluate the ternary operator ? :, which is the operator with the lowest precedence in this operation, and return a result.</p>
<p>I hope you can see, from this example, that the properties of arity, associativity and precedence neatly divide the conceptual space for operator interaction. With them, as well as an understanding of the valid inputs to and outputs from an operator, you can learn precisely about the relationships between operators. As a next step, you might want to consult a comparative table like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">this one</a>.</p>
    <img class="fade" src="./resources/bottom-fade.png" alt="an image that adds a fade effect to the bottom layer" />
  </div>
  <h3 class="expandContractButton">Read more +</h3>
</article>
  </main>
  <footer>
    <nav>
      <h3><a class="current-page" href="./tag-operators.html">0</a></h3>
    </nav>
    <nav>
      <h3><a href="./index.html">Home</a></h3>
      <h3><a href="./archive.html">Archives</a></h3>
      <h3><a href="./about.html">About</a></h3>
      <h3><a href="https://github.com/ievans147/blog" target="_blank">Source code</a></h3>
    </nav>
  </footer>
  <script src="resources/text-expander.js"></script>
</body>
</html>